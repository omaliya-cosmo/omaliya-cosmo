import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/app/lib/prisma"; // OnePay callback handler - handles POST requests with JSON payloadexport async function POST(request: NextRequest) {  try {    console.log("üîî OnePay callback received - POST method");    // Parse the JSON body from OnePay    const body = await request.json();    console.log("üìã OnePay callback payload:", body);    // Extract data according to OnePay documentation format    const { transaction_id, status, status_message, additional_data } = body;    // Validate required fields    if (!transaction_id || status === undefined) {      console.error("‚ùå Missing required OnePay callback parameters:", {        transaction_id,        status,        status_message,      });      return NextResponse.json(        { success: false, error: "Invalid callback parameters" },        { status: 400 }      );    }    // Check if payment was successful (ONLY status = 1 means SUCCESS)    const isSuccess = status === 1;    console.log(`üí∞ OnePay payment ${isSuccess ? "SUCCESS" : "FAILED"}:`, {      transaction_id,      status: `${status} (${isSuccess ? 'SUCCESS' : 'FAILED'})`,      status_message,      additional_data,    });    if (isSuccess) {      // Payment successful - find and update the order      try {        // Find the most recent PENDING_PAYMENT order for OnePay        const order = await prisma.order.findFirst({          where: {            status: "PENDING_PAYMENT",            paymentMethod: "ONEPAY",          },          orderBy: {            id: "desc", // Get the most recent order          },        });        if (!order) {          console.error(            "‚ùå No PENDING_PAYMENT OnePay order found for transaction:",            transaction_id          );          return NextResponse.json(            { success: false, error: "Order not found" },            { status: 404 }          );        }        console.log(          `üîç Found order ${order.id} for transaction ${transaction_id}`        );        // Update order status from PENDING_PAYMENT to PENDING        const updatedOrder = await prisma.order.update({          where: { id: order.id },          data: {            status: "PENDING", // Change from PENDING_PAYMENT to PENDING            paymentTransactionId: transaction_id,            paymentMethod: "ONEPAY",          },        });        console.log(          `‚úÖ Order ${updatedOrder.id} updated successfully: PENDING_PAYMENT ‚Üí PENDING`        );        console.log(`üí∞ Transaction ID: ${transaction_id}`);        // Return success response to OnePay        return NextResponse.json({          success: true,          message: "Payment processed successfully",          orderId: order.id,          transactionId: transaction_id,        });      } catch (dbError) {        console.error("‚ùå Database error updating order:", dbError);        return NextResponse.json(          { success: false, error: "Database update failed" },          { status: 500 }        );      }    } else {      // Payment failed - don't update order status      console.log(        `‚ùå OnePay payment failed for transaction ${transaction_id} with status ${status}:`,        status_message      );      return NextResponse.json({        success: false,        error: "Payment failed",        status: status_message || "FAILED",        transactionId: transaction_id,      });    }  } catch (error) {    console.error("‚ùå OnePay callback processing error:", error);    return NextResponse.json(      { success: false, error: "Callback processing failed" },      { status: 500 }    );  }}// Handle GET requests (for direct user redirects from OnePay)export async function GET(request: NextRequest) {  console.log("üîî OnePay callback received - GET method (user redirect)");  // For GET requests, check query parameters  const { searchParams } = new URL(request.url);  const transaction_id = searchParams.get("transaction_id");  const status = searchParams.get("status");    console.log("üìã GET callback parameters:", {    transaction_id,    status,    url: request.url,    searchParams: Object.fromEntries(searchParams.entries())  });    // If no parameters, we need to be careful - don't assume success  if (!transaction_id && !status) {    console.log("‚ö†Ô∏è No parameters in GET callback - cannot determine payment status");        return NextResponse.redirect(      new URL("/checkout?error=payment_status_unknown&message=Please verify your payment status", request.url)    );  }  // Only proceed if we have status information  if (status) {    console.log(`üîç Processing payment with status: ${status}`);        // Only accept status = "1" as success (matching POST callback format)    if (status === "1") {      console.log("‚úÖ Payment successful (status = 1)");            // Payment successful - find and update order      try {        let order;                // Try to find by transaction ID first        if (transaction_id) {          order = await prisma.order.findFirst({            where: {              paymentTransactionId: transaction_id,            },          });        }                // If not found by transaction ID, find most recent pending order        if (!order) {          order = await prisma.order.findFirst({            where: {              status: "PENDING_PAYMENT",              paymentMethod: "ONEPAY",            },            orderBy: {              id: "desc",            },          });        }        if (order && order.status === "PENDING_PAYMENT") {          // Update order to PENDING only if it's currently PENDING_PAYMENT          const updatedOrder = await prisma.order.update({            where: { id: order.id },            data: {              status: "PENDING",              paymentMethod: "ONEPAY",              paymentTransactionId: transaction_id || `ONEPAY_${order.id}_${Date.now()}`,            },          });                    console.log(`‚úÖ Order ${updatedOrder.id} updated: PENDING_PAYMENT ‚Üí PENDING (Success)`);                    return NextResponse.redirect(            new URL(`/order-confirmation?orderId=${order.id}`, request.url)          );        } else if (order) {          // Order found but already processed          console.log(`‚ÑπÔ∏è Order ${order.id} already processed with status: ${order.status}`);          return NextResponse.redirect(            new URL(`/order-confirmation?orderId=${order.id}`, request.url)          );        } else {          console.error("‚ùå No order found for successful payment");          return NextResponse.redirect(            new URL("/checkout?error=order_not_found", request.url)          );        }      } catch (error) {        console.error("‚ùå Error processing successful payment:", error);        return NextResponse.redirect(          new URL("/checkout?error=processing_failed", request.url)        );      }    } else {      // Payment failed - any status other than "1" is considered failure      console.log(`‚ùå Payment failed with status: ${status} (Only status="1" is success)`);      return NextResponse.redirect(        new URL(`/checkout?error=payment_failed&status=${status}`, request.url)      );    }  } else {    // No status parameter - redirect with unknown status    console.log("‚ö†Ô∏è No status parameter in GET callback");    return NextResponse.redirect(      new URL("/checkout?error=payment_status_unknown", request.url)    );  }}
